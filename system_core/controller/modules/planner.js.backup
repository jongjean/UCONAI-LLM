/**
 * UCONAI Planner v1.0 (Contract C1: Fixed Schema)
 * 
 * Objective: Convert natural language into structured execution plans.
 * Safety: Strict JSON Schema validation with retry budget.
 */

const Ajv = require('ajv');

// [Contract C1] Fixed JSON Schema v1.0
const PLAN_SCHEMA = {
    type: "object",
    required: ["schema_version", "goal", "steps", "max_steps"],
    properties: {
        schema_version: {
            type: "string",
            enum: ["1.0"]
        },
        goal: {
            type: "string",
            minLength: 1,
            maxLength: 500
        },
        steps: {
            type: "array",
            minItems: 1,
            maxItems: 10, // Safety limit
            items: {
                type: "object",
                required: ["id", "tool", "args", "expected"],
                properties: {
                    id: { type: "string" },
                    tool: { type: "string" },
                    args: { type: "object" },
                    expected: {
                        type: "object",
                        additionalProperties: true, // Allow for LLM variation
                        properties: {
                            checks: {
                                type: "array",
                                items: {
                                    type: "object",
                                    required: ["type"],
                                    properties: {
                                        type: { type: "string" },
                                        path: { type: "string" },
                                        regex: { type: "string", maxLength: 200 }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        max_steps: {
            type: "integer",
            minimum: 1,
            maximum: 10
        }
    }
};

const ajv = new Ajv();
const validatePlan = ajv.compile(PLAN_SCHEMA);

class Planner {
    constructor() {
        this.MAX_RETRIES = 2;
    }

    /**
     * Generate execution plan from user request
     * @param {Object} job - { module, action, args, chat_history }
     * @param {Object} llmClient - LLM Client instance
     * @returns {Promise<Object>} - Validated plan or error
     */
    async generatePlan(job, llmClient, attempt = 1) {
        const prompt = this._buildPrompt(job);

        try {
            // Call LLM
    async generatePlan(job, llmClient) {
                const MAX_ATTEMPTS = 2;
                let lastError = null;

                for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
                    try {
                        const prompt = this._buildPrompt(job);
                        const plannerStartTime = Date.now();

                        // [Phase 4.2 Observability] Pass context for metrics
                        const rawResponse = await llmClient.generateLocal(prompt, 'PLANNER');

                        const plannerLatency = Date.now() - plannerStartTime;
                        console.log(`[Planner] Generated plan in ${plannerLatency}ms (attempt ${attempt})`);

                        // Extract JSON from response (LLM might wrap it in markdown)
                        const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);
                        if (!jsonMatch) {
                            throw new Error('No JSON found in LLM response');
                        }

                        const plan = JSON.parse(jsonMatch[0]);

                        // Validate against schema
                        const valid = validatePlan(plan);
                        if (!valid) {
                            const errors = validatePlan.errors.map(e => `${e.instancePath} ${e.message}`).join(', ');
                            console.error(`[Planner] SCHEMA FAIL: ${errors} | RAW: ${jsonMatch[0]}`);
                            throw new Error(`Schema validation failed: ${errors}`);
                        }

                        return {
                            success: true,
                            plan: plan,
                            meta: {
                                planner_latency_ms: plannerLatency,
                                llm_attempt: attempt,
                                llm_context: 'PLANNER',
                                // llm_model: 'qwen3:4b' // Model info should come from llmClient
                            }
                        };

                    } catch (error) {
                        lastError = error;
                        console.warn(`[Planner] Attempt ${attempt} failed: ${error.message}. Retrying...`);

                        if (attempt < MAX_ATTEMPTS) {
                            await new Promise(r => setTimeout(r, 1000 * attempt)); // Simple backoff
                        }
                    }
                }

                // Final failure
                return {
                    success: false,
                    error: 'PARSE_ERR',
                    reason: `Failed after ${MAX_ATTEMPTS} attempts: ${lastError.message}`,
                    meta: {
                        error_code: lastError.code || 'E_PLANNER_FAIL',
                        llm_context: 'PLANNER',
                        llm_attempt: MAX_ATTEMPTS
                    }
                };
            }

            _buildPrompt(job) {
                return `You are a task planner. Convert the user's request into a structured execution plan.

CRITICAL RULES:
1. Output ONLY valid JSON matching this schema:
{
  "schema_version": "1.0",
  "goal": "brief description",
  "steps": [
    {
      "id": "step_1",
      "tool": "read_file" | "system_status" | "write_file",
      "args": { /* for write_file use: path, content */ },
      "expected": { "type": "file_exists" | "contains_text" | "status_ok" | "any" }
    }
  ],
  "max_steps": 3
}

2. Available tools: "system_status", "read_file", "write_file"
3. Use max 3 steps for Phase 4.

USER REQUEST:
Module: ${job.module}
Action: ${job.action}
Args: ${JSON.stringify(job.args)}

Output ONLY the JSON plan:`;
            }
        }

module.exports = new Planner();
